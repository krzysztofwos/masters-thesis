<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.34">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>appendix-02-mathematical-details – MENACE as a Bayesian Observer</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-c8ad9e5dbd60b7b70b38521ab19b7da4.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-a14e3238c51140e99ccc48519b6ed9ce.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="a2-dirichlet-categorical-conjugacy-proof" class="level2">
<h2 class="anchored" data-anchor-id="a2-dirichlet-categorical-conjugacy-proof">A2: Dirichlet-Categorical Conjugacy Proof</h2>
<p><span class="highlight">Theorem:</span> If <span class="math inline">\(\theta \sim \text{Dir}(\alpha)\)</span> and <span class="math inline">\(n\)</span> outcomes are observed, then: <span class="math display">\[\theta|\text{data} \sim \text{Dir}(\alpha + n)\]</span></p>
<p><span class="highlight">Proof:</span></p>
<p><span class="math display">\[
\begin{align}
p(\theta|\text{data}) &amp;\propto p(\text{data}|\theta)p(\theta) \\
&amp;= \prod_{i=1}^{k} \theta_i^{n_i} \cdot \frac{1}{B(\alpha)} \prod_{i=1}^{k} \theta_i^{\alpha_i-1} \\
&amp;\propto \prod_{i=1}^{k} \theta_i^{\alpha_i + n_i - 1}
\end{align}
\]</span></p>
<p>This is the kernel of <span class="math inline">\(\text{Dir}(\alpha + n)\)</span> ∎</p>
<div class="notes">
<p>If <span class="math inline">\(\theta\)</span> is drawn from a Dirichlet with parameters <span class="math inline">\(\alpha\)</span>, and <span class="math inline">\(n\)</span> outcomes are observed, then <span class="math inline">\(\theta\)</span> given data is Dirichlet with parameters <span class="math inline">\(\alpha\)</span> plus <span class="math inline">\(n\)</span>.</p>
<p>This proof shows why MENACE’s bead-updating mechanism is mathematically elegant.</p>
<p>The Dirichlet-categorical conjugacy means that starting with a Dirichlet prior (initial bead counts) and observing categorical data (game outcomes), the posterior is also Dirichlet with updated parameters.</p>
<p>In MENACE’s context:</p>
<ul>
<li>The initial bead counts <span class="math inline">\(\alpha\)</span> represent prior beliefs about which moves are good</li>
<li>Each game outcome adds evidence: winning adds to the count for moves that led to victory</li>
<li>Win/draw increments are additive evidence; loss decrements are a heuristic/forgetting step</li>
<li>The posterior <span class="math inline">\(\text{Dir}(\alpha + n)\)</span> is the updated belief after incorporating this evidence</li>
</ul>
<p>The key property is that updating only requires adding integers — no complex calculations needed. This is why Michie could implement Bayesian inference with physical beads: the mathematics naturally maps to counting operations.</p>
<p>This conjugacy is not a coincidence but reflects a deep connection between counting and probability. The Dirichlet distribution is the natural prior for categorical probabilities precisely because it makes updating trivial through simple addition.</p>
</div>
</section>
<section id="a3-posterior-predictive-probability-matching" class="level2">
<h2 class="anchored" data-anchor-id="a3-posterior-predictive-probability-matching">A3: Posterior Predictive Probability Matching</h2>
<p><span class="highlight">Theorem:</span> Drawing beads = posterior predictive probability matching.</p>
<p><span class="highlight">Proof:</span> For a Dirichlet–categorical model,</p>
<p><span class="math display">\[P(a) = \int \theta_a \cdot \text{Dir}(\theta; \alpha) \, d\theta = \frac{\alpha_a}{\sum_i \alpha_i}\]</span></p>
<p>MENACE’s probability <span class="math display">\[P(a) = \frac{\text{# beads of color } a}{\text{total beads}} = \frac{\alpha_a}{\sum_i \alpha_i}\]</span></p>
<p>Identical ∎</p>
<div class="legend">
<p><span class="math inline">\(P(a)\)</span>: probability of action <span class="math inline">\(a\)</span> &nbsp;&nbsp;•&nbsp;&nbsp; <span class="math inline">\(\theta_a\)</span>: move probability for action <span class="math inline">\(a\)</span> &nbsp;&nbsp;•&nbsp;&nbsp; <span class="math inline">\(\text{Dir}(\theta; \alpha)\)</span>: Dirichlet distribution &nbsp;&nbsp;•&nbsp;&nbsp; <span class="math inline">\(\alpha_a\)</span>: bead count for action <span class="math inline">\(a\)</span> &nbsp;&nbsp;•&nbsp;&nbsp; <span class="math inline">\(\sum_i \alpha_i\)</span>: total beads</p>
</div>
<div class="notes">
<p>The probability of action <span class="math inline">\(a\)</span> equals the integral of <span class="math inline">\(\theta_a\)</span> times the Dirichlet density, which equals <span class="math inline">\(\alpha_a\)</span> over the sum of all alphas.</p>
<p>MENACE samples directly from the posterior predictive distribution (the Dirichlet mean). This is probability matching, not canonical Thompson sampling.</p>
<p>Thompson sampling would first sample <span class="math inline">\(\theta \sim \text{Dir}(\alpha)\)</span> and then take <span class="math inline">\(\arg\max_a \theta_a\)</span>. MENACE instead samples actions in proportion to <span class="math inline">\(\alpha/\alpha_0\)</span>, which naturally implements mixed strategies.</p>
</div>
</section>
<section id="a4-dirichletcategorical-mutual-information" class="level2">
<h2 class="anchored" data-anchor-id="a4-dirichletcategorical-mutual-information">A4: Dirichlet–Categorical Mutual Information</h2>
<p>Epistemic value in the thesis is the mutual information between observations and parameters.</p>
<p><span class="math display">\[I(o;\theta) = H\!\left[\text{Cat}\!\left(\frac{\alpha}{\alpha_0}\right)\right] - \left[\psi(\alpha_0 + 1) - \sum_i \frac{\alpha_i}{\alpha_0} \psi(\alpha_i + 1)\right]\]</span></p>
<p>Equivalent form:</p>
<p><span class="math display">\[I(o;\theta) = \sum_i \frac{\alpha_i}{\alpha_0}\!\left[\psi(\alpha_i{+}1)-\psi(\alpha_0{+}1)-\ln\!\frac{\alpha_i}{\alpha_0}\right] \ge 0\]</span></p>
<p>As total concentration <span class="math inline">\(\alpha_0\)</span> becomes large, <span class="math inline">\(I(o;\theta) \to 0\)</span>.</p>
<div class="legend">
<p><span class="math inline">\(I(o;\theta)\)</span>: mutual information &nbsp;&nbsp;•&nbsp;&nbsp; <span class="math inline">\(o\)</span>: observation (action or outcome) &nbsp;&nbsp;•&nbsp;&nbsp; <span class="math inline">\(\theta \sim \text{Dir}(\alpha)\)</span>: probability vector &nbsp;&nbsp;•&nbsp;&nbsp; <span class="math inline">\(\alpha_i\)</span>: concentration parameter for category <span class="math inline">\(i\)</span> &nbsp;&nbsp;•&nbsp;&nbsp; <span class="math inline">\(\alpha_0 = \sum_i \alpha_i\)</span>: total concentration &nbsp;&nbsp;•&nbsp;&nbsp; <span class="math inline">\(\psi\)</span>: digamma function &nbsp;&nbsp;•&nbsp;&nbsp; <span class="math inline">\(H\)</span>: entropy</p>
</div>
<div class="notes">
<p>The mutual information between observations <span class="math inline">\(o\)</span> and parameters <span class="math inline">\(\theta\)</span> equals the entropy of the categorical distribution minus the expected conditional entropy, expressed using digamma functions <span class="math inline">\(\psi\)</span>.</p>
<p>This formula quantifies epistemic value — how much observing a sample from the categorical distribution reveals about the underlying parameters. In MENACE’s context, <span class="math inline">\(o\)</span> can be either an action selection (at the matchbox level) or a game outcome (at the trajectory level), depending on what Dirichlet is being queried.</p>
<p>The first form decomposes mutual information as entropy minus conditional entropy. The term <span class="math inline">\(H[\text{Cat}(\alpha/\alpha_0)]\)</span> is the entropy of the posterior predictive categorical distribution (uncertainty about the next observation). The bracketed term is the expected entropy of the likelihood given the parameters.</p>
<p>The equivalent form makes the non-negativity explicit. Each term in the sum is non-negative because the digamma function satisfies <span class="math inline">\(\psi(x+1) - \psi(y+1) \geq \ln(x/y)\)</span> when <span class="math inline">\(x \leq y\)</span>.</p>
<p>The key insight: as concentration <span class="math inline">\(\alpha_0\)</span> grows, mutual information shrinks toward zero. With high concentration (high confidence), the probabilities are already well-estimated — observing another sample teaches little. With low concentration (high uncertainty), each observation is highly informative.</p>
<p>This explains why epistemic value matters early in learning but diminishes over time. An agent that weights epistemic value highly will explore more when uncertain, then naturally transition to exploitation as beliefs consolidate.</p>
</div>
</section>
<section id="a5-deriving-variational-free-energy" class="level2">
<h2 class="anchored" data-anchor-id="a5-deriving-variational-free-energy">A5: Deriving Variational Free Energy</h2>
<p><span class="highlight">Goal:</span> Approximate intractable posterior <span class="math inline">\(p(s|o)\)</span> with tractable <span class="math inline">\(q(s|o)\)</span>.</p>
<p><span class="math display">\[
\begin{align}
D_{KL}[q(s|o) \| p(s|o)] &amp;= \mathbb{E}_q\left[\ln q(s|o) - \ln \frac{p(o|s)p(s)}{p(o)}\right] \\
&amp;= \mathbb{E}_q[\ln q(s|o) - \ln p(o|s) - \ln p(s)] + \ln p(o) \\
&amp;= \underbrace{D_{KL}[q(s|o) \| p(s)] - \mathbb{E}_q[\ln p(o|s)]}_{F \;=\; \text{Free Energy}} + \ln p(o)
\end{align}
\]</span></p>
<p>Since <span class="math inline">\(D_{KL} \geq 0\)</span>: <span class="math inline">\(\quad F \geq -\ln p(o) = \text{Surprise}\)</span></p>
<p><span class="highlight">Key insight:</span> Minimizing <span class="math inline">\(F\)</span> simultaneously approximates the posterior and bounds surprise.</p>
<div class="legend">
<p><span class="math inline">\(q(s|o)\)</span>: approximate posterior &nbsp;&nbsp;•&nbsp;&nbsp; <span class="math inline">\(p(s|o)\)</span>: true posterior &nbsp;&nbsp;•&nbsp;&nbsp; <span class="math inline">\(p(o)\)</span>: evidence/marginal likelihood &nbsp;&nbsp;•&nbsp;&nbsp; <span class="math inline">\(F\)</span>: variational free energy</p>
</div>
<div class="notes">
<p>This derivation shows how variational free energy arises from trying to minimize KL divergence between an approximate posterior and the true posterior.</p>
<p>Starting with the KL divergence definition and applying Bayes’ rule to expand <span class="math inline">\(p(s|o)\)</span>, we can rearrange terms to isolate what we call free energy.</p>
<p>The key insight is that since KL divergence is always non-negative, free energy is always an upper bound on surprise (negative log evidence). Minimizing free energy therefore accomplishes two things simultaneously: it makes the approximate posterior closer to the true posterior, and it minimizes surprise about observations.</p>
<p>This is the mathematical foundation for why Active Inference agents minimize free energy — it is a tractable proxy for minimizing surprise while performing approximate Bayesian inference.</p>
</div>
</section>
<section id="a6-three-equivalent-forms-of-free-energy" class="level2">
<h2 class="anchored" data-anchor-id="a6-three-equivalent-forms-of-free-energy">A6: Three Equivalent Forms of Free Energy</h2>
<div class="white-math">
<table class="caption-top table">
<colgroup>
<col style="width: 14%">
<col style="width: 85%">
</colgroup>
<thead>
<tr class="header">
<th>Form</th>
<th>Equation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Energy − Entropy</td>
<td><span class="math inline">\(F = \underbrace{-\mathbb{E}_q[\ln p(o,s)]}_{\text{Energy}} + \underbrace{H[q(s \mid o)]}_{\text{Entropy}}\)</span></td>
</tr>
<tr class="even">
<td>Complexity − Accuracy</td>
<td><span class="math inline">\(F = \underbrace{D_{KL}[q \parallel p(s)]}_{\text{Complexity}} - \underbrace{\mathbb{E}_q[\ln p(o \mid s)]}_{\text{Accuracy}}\)</span></td>
</tr>
<tr class="odd">
<td>Divergence + Surprise</td>
<td><span class="math inline">\(F = \underbrace{D_{KL}[q \parallel p(s \mid o)]}_{\text{Divergence}} + \underbrace{(-\ln p(o))}_{\text{Surprise}}\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>Each form highlights a different trade-off:</p>
<ul>
<li><span class="highlight">Energy−Entropy:</span> Fit data while maintaining uncertainty</li>
<li><span class="highlight">Complexity−Accuracy:</span> Simple models that explain data well</li>
<li><span class="highlight">Divergence+Surprise:</span> Approximate inference while minimizing surprise</li>
</ul>
<div class="notes">
<p>These three formulations of variational free energy are mathematically equivalent but emphasize different aspects of the optimization.</p>
<p>The Energy-Entropy form comes from statistical mechanics and shows the balance between fitting observations (low energy) and maintaining appropriate uncertainty (high entropy).</p>
<p>The Complexity-Accuracy form is common in machine learning. Complexity penalizes posteriors that deviate from the prior, while accuracy rewards explaining the data. This is the form used in variational autoencoders.</p>
<p>The Divergence-Surprise form most directly connects to Active Inference. It shows that free energy equals the gap between approximate and true posteriors plus surprise. When the approximate posterior equals the true posterior, free energy equals surprise exactly.</p>
<p>For MENACE and Active Inference, the Complexity-Accuracy form is most relevant: risk corresponds to the accuracy term (achieving preferred outcomes), while the Dirichlet prior provides implicit complexity regularization.</p>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/krzysztofwos\.github\.io\/masters-thesis\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>